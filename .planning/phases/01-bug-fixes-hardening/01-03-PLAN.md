---
phase: 01-bug-fixes-hardening
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - components/auth/login-form.tsx
  - lib/auth/session.ts
  - components/auth-provider.tsx
autonomous: true
requirements:
  - FIX-01
gap_closure: true

must_haves:
  truths:
    - "Après connexion, le cookie auth-token est défini dans le navigateur"
    - "deleteMessage Server Action peut lire le cookie auth-token et ne retourne plus 'Non authentifié'"
    - "Le cookie est rafraîchi automatiquement quand Firebase renouvelle le token (toutes les heures)"
  artifacts:
    - path: "lib/auth/session.ts"
      provides: "Server Action setAuthCookie qui écrit le cookie httpOnly auth-token"
      exports: ["setAuthCookie", "clearAuthCookie"]
    - path: "components/auth/login-form.tsx"
      provides: "Appel à setAuthCookie après signInWithEmailAndPassword"
      contains: "setAuthCookie"
    - path: "components/auth-provider.tsx"
      provides: "Rafraîchissement du cookie sur onIdTokenChanged"
      contains: "onIdTokenChanged"
  key_links:
    - from: "components/auth/login-form.tsx"
      to: "lib/auth/session.ts"
      via: "import setAuthCookie, appel après signInWithEmailAndPassword"
      pattern: "setAuthCookie"
    - from: "components/auth-provider.tsx"
      to: "lib/auth/session.ts"
      via: "import setAuthCookie dans onIdTokenChanged"
      pattern: "onIdTokenChanged"
    - from: "app/admin/messages/actions.ts"
      to: "cookie auth-token"
      via: "cookies().get('auth-token') — doit trouver le cookie"
      pattern: "auth-token"
---

<objective>
Corriger le bug "Non authentifié" dans deleteMessage en s'assurant que le cookie auth-token est défini lors du login et maintenu lors des renouvellements de token.

Purpose: Le Server Action deleteMessage lit cookies().get('auth-token') pour vérifier l'identité. Ce cookie n'est jamais défini car login-form.tsx appelle signInWithEmailAndPassword directement sans setter le cookie. La correction consiste à créer un Server Action dédié setAuthCookie et à l'appeler depuis login-form.tsx après la connexion Firebase, et depuis onIdTokenChanged dans auth-provider.tsx pour les refresh automatiques.

Output: Cookie auth-token défini après login, rafraîchi automatiquement, deleteMessage fonctionne sans erreur.
</objective>

<execution_context>
@C:/Users/Samuel/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Samuel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-bug-fixes-hardening/01-02-SUMMARY.md
@components/auth/login-form.tsx
@lib/auth/actions.ts
@components/auth-provider.tsx
@app/admin/messages/actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Créer lib/auth/session.ts avec setAuthCookie et clearAuthCookie</name>
  <files>lib/auth/session.ts</files>
  <action>
    Créer un nouveau fichier lib/auth/session.ts avec deux Server Actions.

    Ce fichier est distinct de lib/auth/actions.ts (qui contient loginAction avec next-safe-action) car il doit être importable depuis des Client Components sans conflit de bundling avec next-safe-action.

    Contenu exact du fichier:

    ```typescript
    "use server"

    import { cookies } from "next/headers"

    /**
     * Définit le cookie httpOnly auth-token après connexion Firebase.
     * Appelé depuis les Client Components (login-form, auth-provider) après
     * que Firebase ait authentifié l'utilisateur côté client.
     */
    export async function setAuthCookie(idToken: string): Promise<void> {
      cookies().set({
        name: "auth-token",
        value: idToken,
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "strict",
        path: "/",
        maxAge: 60 * 60, // 1 heure — Firebase renouvelle les tokens toutes les heures
      })
    }

    /**
     * Supprime le cookie auth-token lors de la déconnexion.
     */
    export async function clearAuthCookie(): Promise<void> {
      cookies().delete("auth-token")
    }
    ```

    Note: maxAge de 1 heure (3600 secondes) correspond au TTL des ID tokens Firebase.
    onIdTokenChanged dans auth-provider.tsx appellera setAuthCookie à chaque renouvellement,
    donc le cookie reste valide en continu tant que l'utilisateur est connecté.
  </action>
  <verify>Le fichier lib/auth/session.ts existe et contient les deux exports setAuthCookie et clearAuthCookie.</verify>
  <done>lib/auth/session.ts créé avec "use server", import cookies, exports setAuthCookie et clearAuthCookie.</done>
</task>

<task type="auto">
  <name>Task 2: Appeler setAuthCookie dans login-form.tsx après connexion Firebase</name>
  <files>components/auth/login-form.tsx</files>
  <action>
    Modifier components/auth/login-form.tsx pour appeler setAuthCookie après signInWithEmailAndPassword.

    Changements à apporter:

    1. Ajouter l'import de setAuthCookie en haut du fichier:
       ```typescript
       import { setAuthCookie } from "@/lib/auth/session"
       ```

    2. Dans la fonction handleSubmit, après la ligne `const userCredential = await signInWithEmailAndPassword(...)`,
       et AVANT de récupérer les données Firestore, ajouter:
       ```typescript
       // Définir le cookie auth-token pour les Server Actions
       const idToken = await userCredential.user.getIdToken()
       await setAuthCookie(idToken)
       ```

    3. Changer la redirection intelligente (ligne 55) qui lit `userData?.isAdmin` en `userData?.role === 'admin'`:
       ```typescript
       if (userData?.role === 'admin') {
         router.push("/admin")
       } else {
         router.push("/")
       }
       ```
       (Note: ce fix de casing est inclus ici car login-form.tsx est déjà modifié — évite une double touche du fichier dans le plan suivant)

    Le fichier final dans handleSubmit doit avoir cet ordre:
    1. signInWithEmailAndPassword → userCredential
    2. userCredential.user.getIdToken() → idToken
    3. setAuthCookie(idToken) [await]
    4. getDoc(...) → userData
    5. Redirection selon userData?.role === 'admin'

    Conserver tout le reste du fichier à l'identique (gestion erreurs, UI, etc.).
    Corriger aussi `err: any` en `err: unknown` avec cast interne si TypeScript le signale,
    mais ne pas casser le build pour ça — laisser `any` si nécessaire pour rester stable.
  </action>
  <verify>
    grep -n "setAuthCookie\|role === 'admin'" components/auth/login-form.tsx
    Doit montrer setAuthCookie importé et utilisé, et role === 'admin' à la place de isAdmin.
  </verify>
  <done>
    login-form.tsx appelle setAuthCookie(idToken) après signInWithEmailAndPassword.
    La redirection utilise userData?.role === 'admin' au lieu de userData?.isAdmin.
  </done>
</task>

<task type="auto">
  <name>Task 3: Rafraîchir le cookie sur onIdTokenChanged dans auth-provider.tsx</name>
  <files>components/auth-provider.tsx</files>
  <action>
    Modifier components/auth-provider.tsx pour appeler setAuthCookie sur chaque renouvellement de token Firebase.

    Firebase renouvelle les ID tokens toutes les heures. Sans ce fix, le cookie expirera après 1 heure et deleteMessage retournera "Non authentifié" même si l'utilisateur est toujours connecté côté client.

    Changements à apporter:

    1. Ajouter l'import Firebase nécessaire. La ligne existante importe déjà depuis "firebase/auth".
       Ajouter `onIdTokenChanged` à cet import:
       ```typescript
       import {
         onAuthStateChanged,
         onIdTokenChanged,
         User,
         ...
       } from "firebase/auth"
       ```

    2. Ajouter l'import de session:
       ```typescript
       import { setAuthCookie, clearAuthCookie } from "@/lib/auth/session"
       ```

    3. Dans le useEffect qui écoute les changements d'auth (celui qui appelle `authInstance.onAuthStateChanged`),
       REMPLACER l'appel `authInstance.onAuthStateChanged` par `onIdTokenChanged(auth as Auth, ...)`.

       onIdTokenChanged se déclenche:
       - Quand l'utilisateur se connecte (même comportement que onAuthStateChanged)
       - Quand l'utilisateur se déconnecte (user = null)
       - Quand Firebase renouvelle le token (toutes les heures)

       Nouveau contenu du useEffect (remplacer le bloc try existant):
       ```typescript
       const unsubscribe = onIdTokenChanged(auth as Auth, async (firebaseUser: User | null) => {
         setUser(firebaseUser)
         setIsLoading(false)

         if (firebaseUser) {
           // Rafraîchir le cookie à chaque changement de token (connexion + renouvellement horaire)
           const idToken = await firebaseUser.getIdToken()
           await setAuthCookie(idToken)
         } else {
           // Utilisateur déconnecté — supprimer le cookie
           await clearAuthCookie()
         }
       })

       const timeout = setTimeout(() => {
         setIsLoading(false)
       }, 5000)

       return () => {
         unsubscribe()
         clearTimeout(timeout)
       }
       ```

    4. Supprimer l'import `Auth` depuis "firebase/auth" s'il était déjà utilisé uniquement pour le cast
       (ou conserver s'il est encore nécessaire). Le cast `auth as Auth` est correct.

    Le duck-typing check `typeof authInstance.onAuthStateChanged !== 'function'` peut être simplifié
    puisqu'on utilise maintenant directement onIdTokenChanged avec l'instance typée.
    Supprimer ce check et le remplacement par `authInstance` — utiliser directement `auth`.

    Si auth peut être null/undefined (MockAuthInterface pattern), garder le guard `if (!isConfigured || !auth)`.
  </action>
  <verify>
    grep -n "onIdTokenChanged\|setAuthCookie\|clearAuthCookie" components/auth-provider.tsx
    Doit montrer les trois présents.
  </verify>
  <done>
    auth-provider.tsx utilise onIdTokenChanged au lieu de onAuthStateChanged.
    setAuthCookie est appelé quand l'utilisateur est connecté (user !== null).
    clearAuthCookie est appelé quand l'utilisateur se déconnecte (user === null).
  </done>
</task>

</tasks>

<verification>
Après les 3 tâches:
1. `grep -rn "setAuthCookie" components/auth/login-form.tsx components/auth-provider.tsx` — doit trouver les deux
2. `grep -n "onIdTokenChanged" components/auth-provider.tsx` — doit trouver l'import et l'usage
3. `npx tsc --noEmit 2>&1 | grep -E "login-form|session|auth-provider" | head -20` — aucune nouvelle erreur TS dans ces fichiers
4. Test manuel: Se connecter → Inspecter les cookies navigateur → auth-token présent → tenter deleteMessage → succès
</verification>

<success_criteria>
- lib/auth/session.ts existe avec setAuthCookie et clearAuthCookie exports
- login-form.tsx appelle setAuthCookie(idToken) après signInWithEmailAndPassword
- auth-provider.tsx utilise onIdTokenChanged et appelle setAuthCookie sur chaque token refresh
- deleteMessage ne retourne plus "Non authentifié" quand l'utilisateur est connecté
</success_criteria>

<output>
After completion, create `.planning/phases/01-bug-fixes-hardening/01-03-SUMMARY.md`
</output>
