---
phase: 02-rbac-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/create-shared-accounts.ts
  - types/index.ts
  - hooks/use-user-data.tsx
  - lib/firebase-helpers.ts
  - lib/firebase-utils.ts
autonomous: false
requirements:
  - RBAC-01
  - RBAC-02
  - RBAC-03
  - RBAC-04

must_haves:
  truths:
    - "Le compte ami07@epls.fr existe dans Firebase Auth et son document Firestore a role=ami"
    - "Le compte membre07@epls.fr existe dans Firebase Auth et son document Firestore a role=membre"
    - "Le compte conseil07@epls.fr existe dans Firebase Auth et son document Firestore a role=conseil"
    - "Le type TypeScript Role inclut les 4 niveaux: ami, membre, conseil, admin"
    - "normalizeRole reconnait les nouvelles valeurs ami, membre, conseil"
    - "Aucune erreur TypeScript dans le codebase apres changement de type Role"
  artifacts:
    - path: "scripts/create-shared-accounts.ts"
      provides: "Script Admin SDK pour creer les 3 comptes + docs Firestore"
      min_lines: 40
    - path: "types/index.ts"
      provides: "Type Role mis a jour avec 4 niveaux"
      contains: "ami"
    - path: "hooks/use-user-data.tsx"
      provides: "normalizeRole mis a jour pour 4 niveaux"
      contains: "conseil"
    - path: "lib/firebase-helpers.ts"
      provides: "UserProfile.role mis a jour avec 4 niveaux"
      contains: "ami"
  key_links:
    - from: "scripts/create-shared-accounts.ts"
      to: "lib/firebase-admin.ts"
      via: "Admin SDK import"
      pattern: "firebase-admin"
    - from: "hooks/use-user-data.tsx"
      to: "types/index.ts"
      via: "Role type import or inline"
      pattern: "ami.*membre.*conseil.*admin"
    - from: "lib/firebase-helpers.ts"
      to: "types/index.ts"
      via: "UserProfile.role type alignment"
      pattern: "ami.*membre.*conseil.*admin"
---

<objective>
Create the 3 shared Firebase Auth accounts (ami07, membre07, conseil07) with their Firestore user documents, and update the TypeScript role system from 3 levels (admin/member/visitor) to 4 levels (ami/membre/conseil/admin).

Purpose: Establish the RBAC data foundation so Firestore rules (Plan 02) and route guards (Phase 3) can enforce role-based access.
Output: 3 Firebase Auth accounts with Firestore docs, updated role types across codebase.
</objective>

<execution_context>
@C:/Users/Samuel/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Samuel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-bug-fixes-hardening/01-04-SUMMARY.md
@types/index.ts
@hooks/use-user-data.tsx
@lib/firebase-admin.ts
@lib/firebase-helpers.ts
@lib/firebase-utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update TypeScript role types and normalizeRole for 4-level hierarchy</name>
  <files>types/index.ts, hooks/use-user-data.tsx, lib/firebase-helpers.ts, lib/firebase-utils.ts</files>
  <action>
The role system changes from 'admin' | 'member' | 'visitor' to 'ami' | 'membre' | 'conseil' | 'admin'.

In types/index.ts (line 98):
Change role: 'admin' | 'member' | 'visitor' to role: 'ami' | 'membre' | 'conseil' | 'admin'

In hooks/use-user-data.tsx:
Update UserData.role type (line 16) to 'ami' | 'membre' | 'conseil' | 'admin'
Rewrite normalizeRole (line 26-41) to handle the new hierarchy:

  function normalizeRole(raw: unknown): 'ami' | 'membre' | 'conseil' | 'admin' {
    if (typeof raw !== 'string') return 'ami'
    switch (raw.toLowerCase()) {
      case 'admin':
      case 'administrateur':
        return 'admin'
      case 'conseil':
        return 'conseil'
      case 'member':
      case 'membre':
        return 'membre'
      case 'ami':
      case 'visitor':
      case 'visiteur':
        return 'ami'
      default:
        return 'ami'
    }
  }

Note: 'member' and 'membre' both map to 'membre'. 'visitor' and 'visiteur' map to 'ami' (lowest level). Default is now 'ami' (was 'member').
Update fallback role in the no-document-exists branch (line 91) from 'member' to 'ami'.
Update fallback role in the error branch (line 106) from 'member' to 'ami'.

In lib/firebase-helpers.ts:
Update the UserProfile interface (line 25-38). Change role type at line 31 from:
  role: 'member' | 'admin' | 'visitor'
to:
  role: 'ami' | 'membre' | 'conseil' | 'admin'
Also update saveUserProfile default role (line 126) from 'member' to 'ami'.

In lib/firebase-utils.ts:
Update saveUserProfile default role (line 265) from 'member' to 'ami'.

After modifying the 4 files, run a codebase-wide grep to find any OTHER files that reference the old role values ('member' or 'visitor' as role literals). Fix any cascading type errors in files outside the 4 listed above. Known locations to check:
- app/exemples/components/page.tsx (lines 205-206): update SelectItem values from "member"/"visitor" to "membre"/"ami"
- Any other file that compares role === 'member' or role === 'visitor' must be updated

Do NOT change isAdmin logic (still role === 'admin'). Do NOT change isMember logic yet (still checks !!user). These will be updated in Phase 3 if needed.
  </action>
  <verify>
1. Run npx tsc --noEmit to confirm no type errors across the entire codebase.
2. Run a codebase-wide grep: grep -rn "'member'\|'visitor'" --include="*.ts" --include="*.tsx" to find any remaining old role values. The ONLY acceptable matches are inside normalizeRole switch cases (backward-compat mapping). Any other match is a missed update that must be fixed.
  </verify>
  <done>All files with role types use the new 4-level hierarchy (ami/membre/conseil/admin). UserProfile interface in firebase-helpers.ts is updated. normalizeRole handles backward compatibility. Default role is 'ami' everywhere. Zero TypeScript errors codebase-wide.</done>
</task>

<task type="auto">
  <name>Task 2: Create Admin SDK script for shared accounts and Firestore docs</name>
  <files>scripts/create-shared-accounts.ts</files>
  <action>
Create scripts/create-shared-accounts.ts as a standalone script that uses Firebase Admin SDK to create the 3 shared accounts in Firebase Auth AND their Firestore user documents.

The script must:
1. Import and initialize Firebase Admin SDK directly (NOT from lib/firebase-admin.ts as this is a standalone script, not a Next.js module). Use FIREBASE_SERVICE_ACCOUNT_BASE64 env var (same pattern as lib/firebase-admin.ts).
2. Define the 3 accounts:
   - email: ami07@epls.fr, password: 1chemin9, displayName: Ami EPLS, role: ami
   - email: membre07@epls.fr, password: chemin67, displayName: Membre EPLS, role: membre
   - email: conseil07@epls.fr, password: EPL18Lingo, displayName: Conseil EPLS, role: conseil
3. For each account:
   a. Try admin.auth().createUser({ email, password, displayName }). If auth/email-already-exists, call admin.auth().getUserByEmail(email) to get the uid instead (idempotent).
   b. Use admin.firestore().doc('users/' + uid).set({ uid, email, displayName, role, createdAt: admin.firestore.FieldValue.serverTimestamp() }, { merge: true }). merge:true so re-running is safe.
   c. Log success: Created/updated account: {email} (uid: {uid}, role: {role})
4. Run all 3 sequentially (not parallel) to keep logs readable.
5. Exit with process.exit(0) on success, process.exit(1) on any unrecoverable error.

Add a comment at the top: // Run: npx tsx scripts/create-shared-accounts.ts

The script needs dotenv to load .env.local. Add at the top:
import * as dotenv from 'dotenv';
dotenv.config({ path: '.env.local' });

IMPORTANT: This script runs locally, NOT on Vercel. The user must have .env.local with FIREBASE_SERVICE_ACCOUNT_BASE64 set.
  </action>
  <verify>Run npx tsc --noEmit to check the script compiles. Do NOT run the script yet as it will be run in the checkpoint task.</verify>
  <done>Script file exists, compiles without errors, and contains idempotent account creation logic for all 3 accounts.</done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 3: Run account creation script</name>
  <files>scripts/create-shared-accounts.ts</files>
  <action>
The user must run the account creation script locally. Claude cannot run it because it modifies production Firebase Auth data and requires the service account credentials in .env.local.

Steps for the user:
1. Ensure .env.local contains FIREBASE_SERVICE_ACCOUNT_BASE64 (the base64-encoded service account JSON)
2. Run: npx tsx scripts/create-shared-accounts.ts
3. Verify output shows 3 accounts created/updated with their UIDs and roles
4. In Firebase Console (Authentication tab), confirm the 3 accounts exist: ami07@epls.fr, membre07@epls.fr, conseil07@epls.fr
5. In Firebase Console (Firestore > users collection), confirm each account has a document with the correct role field
  </action>
  <verify>User confirms all 3 accounts exist in Firebase Console with correct roles.</verify>
  <done>All 3 shared accounts exist in Firebase Auth with corresponding Firestore user documents.</done>
</task>

</tasks>

<verification>
- npx tsc --noEmit passes with no type errors
- Codebase-wide grep for 'member' and 'visitor' shows no stale role references (only normalizeRole backward-compat cases)
- types/index.ts User.role type includes ami, membre, conseil, admin
- lib/firebase-helpers.ts UserProfile.role type includes ami, membre, conseil, admin
- hooks/use-user-data.tsx normalizeRole handles all old and new values
- scripts/create-shared-accounts.ts exists and compiles
- All 3 Firebase Auth accounts exist (verified via Firebase Console)
- All 3 Firestore user documents have correct role field
</verification>

<success_criteria>
- The 3 shared accounts (ami07, membre07, conseil07) exist in Firebase Auth
- Each has a Firestore users/{uid} document with the correct role value
- The TypeScript role type uses the 4-level hierarchy (ami < membre < conseil < admin)
- UserProfile interface in lib/firebase-helpers.ts uses the new role type
- normalizeRole handles backward compatibility with old values (member, visitor, etc.)
- No type errors in the codebase (verified with codebase-wide tsc and grep)
</success_criteria>

<output>
After completion, create .planning/phases/02-rbac-foundation/02-01-SUMMARY.md
</output>
