---
phase: 02-rbac-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - firestore.rules
autonomous: true
requirements:
  - RBAC-05

must_haves:
  truths:
    - "La fonction hasRole(minRole) dans les regles Firestore correspond a la hierarchie ami < membre < conseil < admin"
    - "Un utilisateur ne peut pas modifier son propre champ role dans Firestore"
    - "Un utilisateur avec role ami peut lire les documents users mais pas modifier le champ role"
    - "Les regles existantes (isAdmin, collections publiques/privees) continuent de fonctionner"
  artifacts:
    - path: "firestore.rules"
      provides: "Regles Firestore avec hasRole() et protection du champ role"
      contains: "hasRole"
  key_links:
    - from: "firestore.rules"
      to: "Firestore users/{uid}.role"
      via: "get() function reading role field"
      pattern: "get.*users.*role"
    - from: "firestore.rules hasRole()"
      to: "Role hierarchy"
      via: "roleLevel function"
      pattern: "roleLevel"
---

<objective>
Update Firestore security rules with a hasRole(minRole) function that enforces the 4-level role hierarchy, and protect the role field from self-modification by users.

Purpose: Enforce role-based access at the Firestore level so that client-side guards cannot be bypassed.
Output: Updated firestore.rules deployed to Firebase.
</objective>

<execution_context>
@C:/Users/Samuel/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Samuel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@firestore.rules
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hasRole() and roleLevel() to Firestore rules and protect role field</name>
  <files>firestore.rules</files>
  <action>
Update firestore.rules with the following changes. Preserve ALL existing collection rules exactly as they are.

1. Add roleLevel() helper function after the existing isAdmin() function:

// Convertit un role en niveau numerique pour comparaison hierarchique
// Hierarchie: ami(1) < membre(2) < conseil(3) < admin(4)
function roleLevel(role) {
  return role == 'admin' ? 4 :
         role == 'conseil' ? 3 :
         role == 'membre' ? 2 :
         role == 'ami' ? 1 : 0;
}

// Verifie si l'utilisateur connecte a au moins le role minimum requis
function hasRole(minRole) {
  let userRole = get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
  return request.auth != null && roleLevel(userRole) >= roleLevel(minRole);
}

2. Update the users/{userId} rules to prevent self-modification of the role field.

Replace the existing users rules block with:

match /users/{userId} {
  allow read: if request.auth != null;
  allow create: if request.auth != null;
  // Un utilisateur peut modifier son propre document SAUF le champ role
  allow update: if request.auth != null && request.auth.uid == userId
    && (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['role']));
  // Un admin peut tout modifier (y compris le role)
  allow update: if isAdmin();
}

Key changes to users rules:
- allow write is split into allow create and allow update (remove allow write)
- allow update for own document explicitly excludes changes to role field using diff().affectedKeys().hasAny(['role'])
- A separate allow update: if isAdmin() allows admins to change any field including role
- allow create stays as if request.auth != null (new users can create their own doc)

3. Do NOT change any other collection rules. The existing isAdmin() function stays as-is. Do NOT replace isAdmin() calls with hasRole('admin'). That would be a refactor for a future phase.

4. Do NOT use hasRole() on any existing collection rules yet. The function is defined here for Phase 3 to use. For now it just needs to exist and be correct.
  </action>
  <verify>
Validate the rules file syntax. Check:
1. roleLevel function exists and returns correct numeric values for each role
2. hasRole function exists and compares levels
3. Users collection rules prevent role self-modification
4. All other collection rules are unchanged (diff should only show additions to helper functions and users match block)
  </verify>
  <done>firestore.rules contains roleLevel() and hasRole() functions. Users cannot modify their own role field. Admins can still modify any field on any user document. All existing collection rules are preserved exactly.</done>
</task>

<task type="auto">
  <name>Task 2: Deploy Firestore rules to Firebase</name>
  <files>firestore.rules</files>
  <action>
Deploy the updated Firestore rules using Firebase CLI:

npx firebase deploy --only firestore:rules

If Firebase CLI is not installed or not authenticated, log the error and note that the user needs to run npx firebase login first. The firebase.json and .firebaserc files exist in the project root so Firebase CLI should be configured.

If deploy fails due to auth, this becomes a dynamic checkpoint.
  </action>
  <verify>The deploy command outputs success. Alternatively check Firebase Console Firestore Rules to confirm the new rules are active.</verify>
  <done>Firestore rules with hasRole() are live in production. The role field is protected from self-modification.</done>
</task>

</tasks>

<verification>
- firestore.rules contains roleLevel() returning numeric levels for ami(1), membre(2), conseil(3), admin(4)
- firestore.rules contains hasRole(minRole) using roleLevel comparison
- Users collection rules prevent role field modification by the user themselves
- Admin can still update any user field
- All existing collection rules (site_images, gallery_photos, messages, etc.) are unchanged
- Rules are deployed to Firebase
</verification>

<success_criteria>
- hasRole('membre') returns true for users with role membre, conseil, or admin
- hasRole('conseil') returns true for users with role conseil or admin
- hasRole('admin') returns true only for admin users
- A user updating their own document with a role change is DENIED by Firestore rules
- An admin updating any user's role is ALLOWED
</success_criteria>

<output>
After completion, create .planning/phases/02-rbac-foundation/02-02-SUMMARY.md
</output>
