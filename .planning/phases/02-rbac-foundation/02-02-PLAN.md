---
phase: 02-rbac-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - firestore.rules
autonomous: true
requirements:
  - RBAC-05

must_haves:
  truths:
    - "La fonction hasRole(minRole) dans les regles Firestore correspond a la hierarchie ami < membre < conseil < admin"
    - "Un utilisateur ne peut pas modifier son propre champ role dans Firestore"
    - "Un utilisateur avec role ami peut lire les documents users mais pas modifier le champ role"
    - "Les regles existantes (isAdmin, collections publiques/privees) continuent de fonctionner"
    - "Les utilisateurs existants avec role 'member' ou 'visitor' ne sont pas bloques par hasRole()"
  artifacts:
    - path: "firestore.rules"
      provides: "Regles Firestore avec hasRole() et protection du champ role"
      contains: "hasRole"
  key_links:
    - from: "firestore.rules"
      to: "Firestore users/{uid}.role"
      via: "get() function reading role field"
      pattern: "get.*users.*role"
    - from: "firestore.rules hasRole()"
      to: "Role hierarchy"
      via: "roleLevel function"
      pattern: "roleLevel"
---

<objective>
Update Firestore security rules with a hasRole(minRole) function that enforces the 4-level role hierarchy, and protect the role field from self-modification by users.

Purpose: Enforce role-based access at the Firestore level so that client-side guards cannot be bypassed.
Output: Updated firestore.rules deployed to Firebase.
</objective>

<execution_context>
@C:/Users/Samuel/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Samuel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@firestore.rules
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hasRole() and roleLevel() to Firestore rules and protect role field</name>
  <files>firestore.rules</files>
  <action>
Update firestore.rules with the following changes. Preserve ALL existing collection rules exactly as they are.

1. Add roleLevel() helper function after the existing isAdmin() function:

// Convertit un role en niveau numerique pour comparaison hierarchique
// Hierarchie: ami(1) < membre(2) < conseil(3) < admin(4)
// Backward-compat: 'member' maps to 2 (same as membre), 'visitor' maps to 1 (same as ami)
function roleLevel(role) {
  return role == 'admin' ? 4 :
         role == 'conseil' ? 3 :
         role == 'membre' ? 2 :
         role == 'member' ? 2 :
         role == 'ami' ? 1 :
         role == 'visitor' ? 1 : 0;
}

// Verifie si l'utilisateur connecte a au moins le role minimum requis
function hasRole(minRole) {
  let userRole = get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
  return request.auth != null && roleLevel(userRole) >= roleLevel(minRole);
}

IMPORTANT: roleLevel() includes backward-compatible mappings for legacy values:
- 'member' returns 2 (same level as 'membre') so existing users with role='member' are treated as 'membre'
- 'visitor' returns 1 (same level as 'ami') so existing users with role='visitor' are treated as 'ami'
This prevents existing Firestore user documents from being locked out before role migration completes.

2. Delete the ENTIRE existing users/{userId} match block and replace it. The old block to DELETE is:

    // Collection users - lecture authentifiee, ecriture restreinte
    match /users/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null;
    }

Replace it IN ITS ENTIRETY with:

    // Collection users - lecture authentifiee, ecriture restreinte
    match /users/{userId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      // Un utilisateur peut modifier son propre document SAUF le champ role
      allow update: if request.auth != null && request.auth.uid == userId
        && (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['role']));
      // Un admin peut tout modifier (y compris le role)
      allow update: if isAdmin();
    }

CRITICAL: The old "allow write: if request.auth != null && request.auth.uid == userId;" line MUST be completely removed. If it remains, it bypasses the role field protection because 'allow write' includes update with no field restrictions. The new block uses separate 'allow create' and 'allow update' rules instead.

3. Do NOT change any other collection rules. The existing isAdmin() function stays as-is. Do NOT replace isAdmin() calls with hasRole('admin'). That would be a refactor for a future phase.

4. Do NOT use hasRole() on any existing collection rules yet. The function is defined here for Phase 3 to use. For now it just needs to exist and be correct.
  </action>
  <verify>
1. Validate the rules file syntax by checking it parses correctly.
2. Verify roleLevel function returns correct values: admin=4, conseil=3, membre=2, member=2, ami=1, visitor=1, unknown=0.
3. Verify hasRole function exists and compares levels.
4. Verify the old "allow write: if request.auth != null && request.auth.uid == userId" line is GONE from the users match block. Grep for "allow write" in the users section -- it must NOT appear.
5. Verify users collection rules now have: allow read, allow create, two separate allow update rules (one for self without role change, one for admin).
6. Diff the file to confirm all other collection rules are unchanged (only helper functions and users match block should differ).
  </verify>
  <done>firestore.rules contains roleLevel() with backward-compatible mappings and hasRole() functions. The old 'allow write' rule for users is deleted. Users cannot modify their own role field. Admins can still modify any field on any user document. All existing collection rules are preserved exactly.</done>
</task>

<task type="auto">
  <name>Task 2: Deploy Firestore rules to Firebase</name>
  <files>firestore.rules</files>
  <action>
Deploy the updated Firestore rules using Firebase CLI:

npx firebase deploy --only firestore:rules

If Firebase CLI is not installed or not authenticated, log the error and note that the user needs to run npx firebase login first. The firebase.json and .firebaserc files exist in the project root so Firebase CLI should be configured.

If deploy fails due to auth, this becomes a dynamic checkpoint.
  </action>
  <verify>The deploy command outputs success. Alternatively check Firebase Console Firestore Rules to confirm the new rules are active.</verify>
  <done>Firestore rules with hasRole() are live in production. The role field is protected from self-modification.</done>
</task>

</tasks>

<verification>
- firestore.rules contains roleLevel() returning numeric levels for ami(1), membre(2), conseil(3), admin(4) AND backward-compat for member(2), visitor(1)
- firestore.rules contains hasRole(minRole) using roleLevel comparison
- The old "allow write" rule for users/{userId} is completely removed
- Users collection rules prevent role field modification by the user themselves
- Admin can still update any user field
- All existing collection rules (site_images, gallery_photos, messages, etc.) are unchanged
- Rules are deployed to Firebase
</verification>

<success_criteria>
- hasRole('membre') returns true for users with role membre, member, conseil, or admin
- hasRole('conseil') returns true for users with role conseil or admin
- hasRole('admin') returns true only for admin users
- hasRole('ami') returns true for users with role ami, visitor, membre, member, conseil, or admin (everyone)
- A user updating their own document with a role change is DENIED by Firestore rules
- An admin updating any user's role is ALLOWED
- Existing users with legacy role values ('member', 'visitor') are NOT locked out
</success_criteria>

<output>
After completion, create .planning/phases/02-rbac-foundation/02-02-SUMMARY.md
</output>
