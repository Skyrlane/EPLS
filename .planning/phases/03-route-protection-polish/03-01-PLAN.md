---
phase: 03-route-protection-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - components/auth/member-guard.tsx
  - app/infos-docs/membres/page.tsx
  - app/infos-docs/anniversaires/page.tsx
  - app/infos-docs/carnet-adresses/page.tsx
autonomous: true
requirements:
  - PROT-01
  - PROT-02
  - PROT-03
  - PROT-04

must_haves:
  truths:
    - "Un utilisateur non connecté accédant à /infos-docs/membres est redirigé vers /connexion"
    - "Un utilisateur non connecté accédant à /infos-docs/anniversaires est redirigé vers /connexion"
    - "Un utilisateur avec rôle ami accédant à /infos-docs/membres est redirigé vers /acces-refuse"
    - "Un utilisateur avec rôle ami accédant à /infos-docs/anniversaires est redirigé vers /acces-refuse"
    - "Un utilisateur avec rôle membre accédant à /infos-docs/anniversaires voit le contenu"
    - "Un utilisateur avec rôle conseil accédant à /infos-docs/membres voit le contenu"
  artifacts:
    - path: "components/auth/member-guard.tsx"
      provides: "Role-gated guard component with minRole prop"
      contains: "ROLE_LEVEL"
    - path: "app/infos-docs/membres/page.tsx"
      provides: "Membres page wrapped with MemberGuard minRole=conseil"
      contains: "MemberGuard"
    - path: "app/infos-docs/anniversaires/page.tsx"
      provides: "Anniversaires page wrapped with MemberGuard minRole=membre"
      contains: "MemberGuard"
    - path: "app/infos-docs/carnet-adresses/page.tsx"
      provides: "Carnet d'adresses page wrapped with MemberGuard minRole=membre"
      contains: "MemberGuard"
  key_links:
    - from: "components/auth/member-guard.tsx"
      to: "hooks/use-user-data.tsx"
      via: "useUserData() hook for role + loading state"
      pattern: "useUserData"
    - from: "components/auth/member-guard.tsx"
      to: "/acces-refuse"
      via: "router.replace('/acces-refuse') when role insufficient"
      pattern: "acces-refuse"
    - from: "app/infos-docs/membres/page.tsx"
      to: "components/auth/member-guard.tsx"
      via: "MemberGuard wrapper with minRole=conseil"
      pattern: 'minRole="conseil"'
---

<objective>
Create MemberGuard component with role hierarchy checking and apply it to the three protected /infos-docs pages, replacing manual useAuth+useEffect redirects with centralized role-based guards.

Purpose: Enforce role-based access on sensitive pages (membres=conseil+, anniversaires/carnet-adresses=membre+) so lower-privileged users are redirected to /acces-refuse.
Output: MemberGuard component + 3 protected pages wrapped with correct minRole.
</objective>

<execution_context>
@C:/Users/Samuel/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Samuel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-route-protection-polish/03-RESEARCH.md
@components/auth/admin-guard.tsx
@hooks/use-user-data.tsx
@app/infos-docs/membres/page.tsx
@app/infos-docs/anniversaires/page.tsx
@app/infos-docs/carnet-adresses/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MemberGuard component with minRole prop</name>
  <files>components/auth/member-guard.tsx</files>
  <action>
Create `components/auth/member-guard.tsx` by cloning the pattern from `components/auth/admin-guard.tsx` with these modifications:

1. Add a client-side `ROLE_LEVEL` map mirroring Firestore `roleLevel()`:
   ```typescript
   const ROLE_LEVEL: Record<string, number> = {
     admin: 4,
     conseil: 3,
     membre: 2,
     member: 2,   // backward compat
     ami: 1,
     visitor: 1,  // backward compat
   };
   ```

2. Accept `minRole` prop (type: `'ami' | 'membre' | 'conseil' | 'admin'`) and `children`.

3. Use `useUserData()` (NOT `useAuth`) to get `user`, `userData`, and `loading`. The combined `loading` flag from `useUserData` already handles both auth loading and Firestore doc fetch — critical to avoid premature redirects.

4. In the `useEffect`:
   - If `loading`, return early.
   - If `!user`, redirect to `/connexion?callbackUrl={current path}` using `router.replace()` and `encodeURIComponent(window.location.pathname)`.
   - If user exists but `ROLE_LEVEL[userData?.role ?? 'ami'] < ROLE_LEVEL[minRole]`, redirect to `/acces-refuse` using `router.replace()`.

5. Render states:
   - If `loading`: show centered `Loader2` spinner with "Vérification des permissions..." text (same as AdminGuard).
   - If `!user`: return `null` (redirect in progress).
   - If role insufficient: return `null` (redirect in progress).
   - Otherwise: render `children`.

Do NOT use `useProtectedRoute` — it has a known `isLoading` vs `loading` destructuring bug.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors in the new file. Grep for `useUserData` import and `ROLE_LEVEL` map in the file.</verify>
  <done>MemberGuard component exists at `components/auth/member-guard.tsx`, accepts `minRole` prop, uses `useUserData` for role checking, redirects unauthenticated to /connexion and insufficient-role to /acces-refuse.</done>
</task>

<task type="auto">
  <name>Task 2: Apply MemberGuard to trois pages /infos-docs protégées</name>
  <files>
    app/infos-docs/membres/page.tsx
    app/infos-docs/anniversaires/page.tsx
    app/infos-docs/carnet-adresses/page.tsx
  </files>
  <action>
For each of the three pages, replace the manual `useAuth` + `useEffect` redirect pattern with a `MemberGuard` wrapper.

**app/infos-docs/anniversaires/page.tsx** (minRole="membre"):
1. Remove the `useAuth` import and usage (`const { user, loading } = useAuth()`).
2. Remove the `useRouter` import and usage (unless used elsewhere in the page for non-auth navigation).
3. Remove the `useEffect` that redirects to `/connexion`.
4. Remove the `if (loading)` and `if (!user)` early returns.
5. Import `MemberGuard` from `@/components/auth/member-guard`.
6. Wrap the page content with `<MemberGuard minRole="membre">...</MemberGuard>`.
7. The page is still `'use client'` — MemberGuard is a client component wrapping client content.

**app/infos-docs/carnet-adresses/page.tsx** (minRole="membre"):
Same transformation as anniversaires. Note: apply to `carnet-adresses/` (with `s`), NOT `carnet-adresse/`.

**app/infos-docs/membres/page.tsx** (minRole="conseil"):
1. This page uses `useAuth` for `const { user, loading: authLoading } = useAuth()`. Remove that.
2. Remove the `useRouter` import and usage if only used for auth redirect. Check if `router` is used elsewhere first — if yes, keep `useRouter` but remove the auth redirect `useEffect`.
3. Remove the `useEffect` that redirects unauthenticated users.
4. Remove `if (authLoading)` and `if (!user)` early returns.
5. Import `MemberGuard` from `@/components/auth/member-guard`.
6. Wrap the full return JSX with `<MemberGuard minRole="conseil">...</MemberGuard>`.

**Important notes:**
- Keep `'use client'` directive on all pages.
- Keep ALL other imports (data hooks like `useChurchMembers`, `useContacts`, UI components, etc.).
- Keep ALL page content/JSX intact — only change the auth guard wrapper.
- The `useAuth` import can be fully removed since MemberGuard handles auth internally via `useUserData`.

**Known gap (document, do not fix):** Firestore rules for `birthdays` and `contacts` collections only check `request.auth != null`, not role. This is out of scope — client-side MemberGuard is the enforcement layer for Phase 3.
  </action>
  <verify>
1. Run `npx tsc --noEmit` — no type errors.
2. Grep for `MemberGuard` in all three pages — must be present.
3. Grep for `useAuth` in all three pages — must NOT be present (replaced by MemberGuard).
4. Grep for `minRole="conseil"` in membres/page.tsx.
5. Grep for `minRole="membre"` in anniversaires/page.tsx and carnet-adresses/page.tsx.
6. Run `npm run build` to confirm no build errors.
  </verify>
  <done>
All three pages use MemberGuard: /infos-docs/membres requires conseil+, /infos-docs/anniversaires requires membre+, /infos-docs/carnet-adresses requires membre+. No manual useAuth+useEffect auth logic remains in these pages.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors.
2. `npm run build` succeeds.
3. `components/auth/member-guard.tsx` exists and contains `ROLE_LEVEL`, `useUserData`, `minRole` prop, redirects to `/acces-refuse`.
4. All three protected pages import and use `MemberGuard` with correct `minRole` values.
5. No `useAuth` import remains in the three protected pages.
</verification>

<success_criteria>
- MemberGuard component created with role hierarchy comparison (ami < membre < conseil < admin).
- /infos-docs/membres wrapped with MemberGuard minRole="conseil".
- /infos-docs/anniversaires wrapped with MemberGuard minRole="membre".
- /infos-docs/carnet-adresses wrapped with MemberGuard minRole="membre".
- Build passes without errors.
</success_criteria>

<output>
After completion, create `.planning/phases/03-route-protection-polish/03-01-SUMMARY.md`
</output>
